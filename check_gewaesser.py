# -*- coding: utf-8 -*-

"""
/***************************************************************************
 OSWeGe-Tools - a QGIS plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-09
        copyright            : (C) 2024 by Jannik Schilling
        email                : jannik.schilling@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2024-04-09'
__copyright__ = '(C) 2024 by Jannik Schilling'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (NULL,
                       QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterVectorLayer,
                       QgsSpatialIndex)
from collections import Counter
import pandas as pd

from .defaults import (
    distanz_suchen,
    #feld_gew_name,
    minimallaenge_gew,
    oswScriptType,
    oswDataFeedback
)
from .pruefungsroutinen import (
    check_spalte_vorhanden,
    check_wert_fehlend,
    check_geometrie_wasserscheide_senke,
    check_geometrie_leer,
    check_geometrie_multi,
    check_geometrie_selbstueberschneidung,
    check_geometrie_ueberschneidung_mit_anderen,
    check_geometrie_duplikat
)
from .meldungen import fehlermeldungen_generieren

class checkGewaesser(QgsProcessingAlgorithm):
    """
    Prueft Gewaesserdaten
    """
    FELD_GEWNAME = 'FELD_GEWNAME'
    GEWAESSER_LAYER = 'GEWAESSER_LAYER'
    REPORT = 'REPORT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.GEWAESSER_LAYER,
                self.tr('Gewässerlayer'),
                [QgsProcessing.SourceType.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                self.FELD_GEWNAME,
                self.tr('Feld/Attribut eindeutiger Gewässername'),
                parentLayerParameterName = self.GEWAESSER_LAYER,
                defaultValue = 'ba_cd',
                type = QgsProcessingParameterField.Any,
                optional = False
            )
        )


        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.REPORT,
                self.tr('Reportdatei'),
                'Textdatei (*.txt)',
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Hier findet die Verarbeitung statt
        """
        layer_gew = self.parameterAsVectorLayer(parameters, self.GEWAESSER_LAYER, context)
        provider_gew = layer_gew.dataProvider()
        index_gew = QgsSpatialIndex(layer_gew.getFeatures())
        reportdatei = self.parameterAsString(parameters, self.REPORT, context)
        feld_gew_name = self.parameterAsString(parameters, self.FELD_GEWNAME, context)

        # Anzahl Objekte
        total = layer_gew.featureCount() if layer_gew.featureCount() else 0
        total_steps = 100.0/total if total != 0 else 0

        # Zusammenfassendes dictionary fuer Prozessparameter
        params = {
            'layer_gew': layer_gew,
            'provider_gew':provider_gew,
            'feedback': feedback,
            'index_gew': index_gew,
            'feld_gew_name': feld_gew_name,
            'distanz_suchen': distanz_suchen
        }


        # dictionary fuer Feedback / Fehlermeldungen
        report_dict = {}
        """
        report_dict = {
            'Test1': {
                'Typ': 'allgemein',
                'Report': 0 / oswDataFeedback
            },
            'Test2':
                'Typ': 'Attribut',
                'Spalte': 'Spaltenname',
                'Report': oswDataFeedback,
                'Obj': [id1, id2]
            'Test3':
                'Typ': 'Geometrie',
                'Report': oswDataFeedback,
                'Obj': [id1, id2] oder [[id1, id2][id3, id4]]
        }
        """


        # Alle benoetigten Spalten im Layer?
        report_dict['Test_COL_ID_vorhanden'] = {
            'Typ': 'allgemein',
            'Report': check_spalte_vorhanden(
                spaltenname=feld_gew_name,
                layer=layer_gew,
                **params
            )
        }

        # Pruefroutinen fuer Attribute
        if report_dict['Test_COL_ID_vorhanden']['Report'] == 0:
            feedback.setProgressText('Prüfe Attribute:')
            datagen = (
                [
                    ft.id(),
                    ft[feld_gew_name],
                ] for ft in layer_gew.getFeatures()
            )
            df_gew = pd.DataFrame.from_records(
                data=datagen,
                columns=[
                    'id',
                    feld_gew_name
                ]
            )
            del datagen


            # eindeutiger Gewaessername?
            feedback.setProgressText('- eindeutiger Gewaessername')
            name_Counter = Counter(df_gew[feld_gew_name])
            val_list = []
            steps = len(name_Counter)/100
            i = 0
            for val, ct in name_Counter.items():
                if val != NULL:
                    if ct == 1:
                        pass
                    else:
                        val_list = val_list + [df_gew.loc[df_gew[feld_gew_name]==val, 'id'].tolist()]
                i = i+1
                feedback.setProgress(int(i * steps))
            report_dict['Test_VAL_ID_DUPLICAT'] = {
                    'Typ': 'Attribut',
                    'Spalte': feld_gew_name,
                    'Report': oswDataFeedback.VAL_DUPLICAT,
                    'Objekte': val_list
                }
                


            # fehlender Gewaessername?
            feedback.setProgressText('- fehlende Gewaessernamen')
            val_list = []
            for i, val in enumerate(df_gew[feld_gew_name]):
                if check_wert_fehlend(val) == 0:
                    pass
                else:
                    val_list = val_list + [df_gew.loc[i, 'id']]
                feedback.setProgress(int(i * total_steps))
            report_dict['Test_VAL_ID_MISSING'] = {
                'Typ': 'Attribut',
                'Spalte': feld_gew_name,
                'Report': oswDataFeedback.VAL_MISSING,
                'Objekte': val_list
            }


        # Pruefroutinen fuer Geometrien
        datagen = (
            [
                ft.id(),
                ft.geometry()
            ] for ft in layer_gew.getFeatures()
        )
        df_gew = pd.DataFrame.from_records(
            data=datagen,
            columns=[
                'id',
                'geometrie'
            ]
        )
        del datagen

        # leere Geometrien
        feedback.setProgressText('Prüfe Geometrien:')
        feedback.setProgressText('- leere Geometrien')
        val_list = []
        for i, val in enumerate(df_gew['geometrie']):
            if check_geometrie_leer(val) == 0:
                pass
            else:
                val_list = val_list + [df_gew.loc[i, 'id']]
            feedback.setProgress(int(i * total_steps))
        report_dict['Test_GEOM_EMPTY'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_EMPTY,
            'Objekte': val_list
        }

        # Multigeometrien
        feedback.setProgressText('- Multigeometrien')
        val_list = []
        for i, val in enumerate(df_gew['geometrie']):
            if check_geometrie_multi(val) == 0:
                pass
            else:
                val_list = val_list + [df_gew.loc[i, 'id']]
            feedback.setProgress(int(i * total_steps))
        report_dict['Test_GEOM_MULTI'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_MULTI,
            'Objekte': val_list
        }


        # Selbstueberschneidungen
        feedback.setProgressText('- Selbstüberschneidungen')
        val_list = []
        for i, val in enumerate(df_gew['geometrie']):
            if check_geometrie_selbstueberschneidung(val) == 0:
                pass
            else:
                val_list = val_list + [df_gew.loc[i, 'id']]
            feedback.setProgress(int(i * total_steps))
        report_dict['Test_GEOM_SELFINTERSECT'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_SELFINTERSECT,
            'Objekte': val_list
        }

        # Ueberschneidung mit anderen Geometrien
        feedback.setProgressText('- Ueberschneidung mit anderen Geometrien')
        val_list = []
        for i, geom in enumerate(df_gew['geometrie']):
            check = check_geometrie_ueberschneidung_mit_anderen(
                geom,
                df_gew.loc[i, 'id'],
                df_gew
            ) 
            if check == 0:
                pass
            else:
                if not any([all(fid in lst for fid in check[1]) for lst in val_list]):
                    val_list = val_list + [check[1]]
            feedback.setProgress(int(i * total_steps))
        report_dict['Test_GEOM_INTERSECT'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_INTERSECT,
            'Objekte': val_list
        }

        # Doppelte Geometrien
        feedback.setProgressText('- Doppelte Geometrien')
        val_list = []
        for i, geom in enumerate(df_gew['geometrie']):
            check = check_geometrie_duplikat(
                geom,
                i,
                df_gew['geometrie'],
                with_id=True,
                df_gew=df_gew
            ) 
            if check == 0:
                pass
            else:
                if not any([all(fid in lst for fid in check[1]) for lst in val_list]):
                    val_list = val_list + [check[1]]
            feedback.setProgress(int(i * total_steps))
        report_dict['Test_GEOM_DUPLICAT'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_DUPLICAT,
            'Objekte': val_list
        }

        # Konnektivitaet
        feedback.setProgressText('- Konnektivität')
        feedback.setProgressText('> Wasserscheiden')
        val_list = []
        for i, geom in enumerate(df_gew['geometrie']):
            check = check_geometrie_wasserscheide_senke(
                geom,
                df_gew.loc[i,'id'],
                senke=False,
                **params
            )
            if check == 0:
                pass
            else:
                dupl = False
                check[1].sort()
                if "Test_GEOM_DUPLICAT" in report_dict.keys():
                    if check[1] in report_dict["Test_GEOM_DUPLICAT"]['Objekte']:
                        dupl = True
                if not dupl:
                    if not any([all(fid in lst for fid in check[1]) for lst in val_list]):
                        val_list = val_list + [check[1]] 
            feedback.setProgress(int(i * total_steps))
        report_dict['Test_GEOM_WASSERSCHEIDE'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_WASSERSCHEIDE,
            'Objekte': val_list
        }

        feedback.setProgressText('> Senken')
        val_list = []
        for i, geom in enumerate(df_gew['geometrie']):
            check = check_geometrie_wasserscheide_senke(
                geom,
                df_gew.loc[i,'id'],
                senke=True,
                **params
            ) 
            if check == 0:
                pass
            else:
                dupl = False
                check[1].sort()
                if "Test_GEOM_DUPLICAT" in report_dict.keys():
                    if check[1] in report_dict["Test_GEOM_DUPLICAT"]['Objekte']:
                        dupl = True
                if not dupl:
                    if not any([all(fid in lst for fid in check[1]) for lst in val_list]):
                        val_list = val_list + [check[1]] 
            feedback.setProgress(int(i * total_steps))
        report_dict['Test_GEOM_SENKE'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_SENKE,
            'Objekte': val_list
        }


        # Bericht zusammenstellen
        with open(reportdatei, 'w') as f:
            f.write(
                '**************************************'
                + '\nÜberprüfung des (Basis-)Gewässerlayers'
                + '\n\nLayer: ' + str(layer_gew)
                + '\n**************************************\n\n'
            )
            for val in report_dict.values():
                f.write(fehlermeldungen_generieren(val))

        feedback.pushInfo('Report gespeichert in ' + str(reportdatei)+ '\n')

        return {}

    def name(self):
        return 'Pruefroutine_Gewaesserlinie'

    def displayName(self):
        return '1_Pruefroutine_Gewaesserlinie'

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Pruefroutinen'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return checkGewaesser()
