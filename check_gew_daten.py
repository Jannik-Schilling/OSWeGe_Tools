# -*- coding: utf-8 -*-

"""
/***************************************************************************
 OSWeGe-Tools - a QGIS plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-09
        copyright            : (C) 2024 by Jannik Schilling
        email                : jannik.schilling@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2024-04-09'
__copyright__ = '(C) 2024 by Jannik Schilling'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import (
    QCoreApplication,
    QVariant
)
from qgis.core import (
    NULL,
    QgsExpression,
    QgsFeatureRequest,
    QgsGeometry,
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsProcessingParameterField,
    QgsProcessingParameterFileDestination,
    QgsProcessingParameterVectorLayer
)
from qgis import processing

from .defaults import (
    distanz_suchen,
    dict_ereign_fehler,
    list_ereign_gew_id_fields,
    minimallaenge_gew,
    oswScriptType,
    pflichtfelder,
)
from .pruefungsroutinen import (
    check_duplicates_crossings,
    check_geometrie_wasserscheide_senke,
    check_geom_on_line,
    get_line_to_check,
    lst_replace
)

class checkGewaesserDaten(QgsProcessingAlgorithm):
    """
    Prueft Gewaesserdaten
    """
    LAYER_GEWAESSER = 'LAYER_GEWAESSER'
    LAYER_ROHLEITUNGEN = 'LAYER_ROHLEITUNGEN'
    LAYER_DURCHLAESSE = 'LAYER_DURCHLAESSE'
    LAYER_WEHRE = 'LAYER_WEHRE'
    LAYER_SCHAECHTE = 'LAYER_SCHAECHTE'
    REPORT = 'REPORT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_GEWAESSER,
                self.tr('Gewässer-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_ROHLEITUNGEN,
                self.tr('Rohrleitungs-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_DURCHLAESSE,
                self.tr('Durchlässe-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_WEHRE,
                self.tr('Wehre-Layer'),
                [QgsProcessing.SourceType.TypeVectorPoint],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_SCHAECHTE,
                self.tr('Schächte-Layer'),
                [QgsProcessing.SourceType.TypeVectorPoint],
                optional = True
            )
        )


        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.REPORT,
                self.tr('Reportdatei'),
                'Json File (*.json)'                #'Textdatei (*.txt)',
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Hier findet die Verarbeitung statt
        """
        layer_gew = self.parameterAsVectorLayer(parameters, self.LAYER_GEWAESSER, context)
        layer_rohrleitungen = self.parameterAsVectorLayer(parameters, self.LAYER_ROHLEITUNGEN, context)
        layer_durchlaesse = self.parameterAsVectorLayer(parameters, self.LAYER_DURCHLAESSE, context)
        layer_wehre = self.parameterAsVectorLayer(parameters, self.LAYER_WEHRE, context)
        layer_schaechte = self.parameterAsVectorLayer(parameters, self.LAYER_SCHAECHTE, context)
        reportdatei = self.parameterAsString(parameters, self.REPORT, context)

        # Zusammenfassendes dictionary fuer Prozessparameter
        params = {
            'layer_dict': {
                'gewaesser': {'layer': layer_gew},
                'rohrleitungen': {'layer': layer_rohrleitungen},
                'durchlaesse': {'layer': layer_durchlaesse},
                'wehre': {'layer': layer_wehre},
                'schaechte': {'layer': layer_schaechte},
            },
            'feedback': feedback,
            'ereign_gew_id_field': list_ereign_gew_id_fields[1],  # gu_cd, ba_cd
            'field_merged_id': 'merged_id',
            'emptystrdef': [NULL, ''],  # mögliche "Leer"-Definitionen für Zeichketten
        }

        # dictionary fuer Feedback / Fehlermeldungen
        report_dict = {}
        """
        report_dict = {
            'gewaesser': {
                'name': 'so heisst die Datei",
                'attribute': {
                    'missing_fields': [],
                    'primary_key_empty': [id1, id2],
                    'primary_key_duplicat': [[id3, id4],[id5, id6, id7]]
                },
                'geometrien': {
                    fehler1: [],
                    fehler2: []
                }
            },
            'rohrleitungen': {
                'name': 'so heisst die Datei",
                'attribute': {
                    'missing_fields': [],
                    #'primary_key_empty': [id1, id2],
                    #'primary_key_duplicat': [[id3, id4],[id5, id6, id7]],
                    'gew_key_empty': [id1, id2],
                    'gew_key_invalid': [id4, id5] /  # nicht im layer_gew
                },
                'geometrien': {
                    fehler1: [],
                    fehler2: []
                }
            }
        }
        """


        for key, value in params['layer_dict'].items():
            layer = value['layer']
            if layer:
                # Anzahl Objekte fuer das Feedback
                ft_count = layer.featureCount() if layer.featureCount() else 0
                layer_steps = 100.0/ft_count if ft_count != 0 else 0
                params['layer_dict'][key].update({
                    'count': ft_count,
                    'steps': layer_steps
                })
                report_dict[key] = {'name': layer.name()}

        if (('rohrleitungen' in report_dict.keys()) and ('durchlaesse' in report_dict.keys())):
            # neues Feld "rldl_id" mit dem Layername und der id() des Objekts, weil sich die id() beim Vereinigen der Layer aendert
            rl_mit_id = processing.run("native:fieldcalculator", {
                'INPUT': params['layer_dict']['rohrleitungen']['layer'],
                'FIELD_NAME': params['field_merged_id'],
                'FIELD_TYPE': 2,
                'FORMULA': "concat(@layer_name,': ',$id)",
                'OUTPUT': 'memory:'
            }) ['OUTPUT']
            dl_mit_id = processing.run("native:fieldcalculator", {
                'INPUT': params['layer_dict']['durchlaesse']['layer'],
                'FIELD_NAME': params['field_merged_id'],
                'FIELD_TYPE': 2,
                'FORMULA': "concat(@layer_name,': ',$id)",
                'OUTPUT': 'memory:'
            })['OUTPUT']
            list_r_layer = [rl_mit_id, dl_mit_id]
            # Vereinigen der layer rl und dl für Überschneidungsanalyse
            layer_rldl = processing.run(
                "native:mergevectorlayers",
                {
                    'LAYERS':list_r_layer,
                    'OUTPUT':'memory:'
                }
            )['OUTPUT']
            params['layer_rldl'] = layer_rldl


        def main_check(key, report_dict, params, feedback):
            """
            Diese Hauptfunktion wird durchlaufen, um die Vektorobjekte alle Layer zu pruefen (Attribute + Geometrien)
            :param str key
            :param dict report_dict
            :param dict params
            :param QgsProcessingFeedback feedback
            """
            feedback.setProgressText('Layer \"'+key+'\":')
            layer = params['layer_dict'][key]['layer']
            # pflichtfelder vorhanden?
            feedback.setProgressText('> Prüfe benötigte Attributfelder...')
            pflichtfelder_i = pflichtfelder[key]
            layer_i_felder = layer.fields().names()
            missing_fields = [feld for feld in pflichtfelder_i if not feld in layer_i_felder]
            layer_steps = params['layer_dict'][key]['steps']

            # Attribute
            feedback.setProgressText('> Prüfe alle Einzelobjekte...')
            ereign_gew_id_field = params['ereign_gew_id_field']
            if ereign_gew_id_field in missing_fields:
                report_dict[key]['attribute'] = {
                    'missing_fields': missing_fields
                }
                feedback.setProgressText(
                   'Feld \"'
                   + ereign_gew_id_field
                   + '\"(Primärschlüssel) fehlt. Attributtest wird übersprungen'
                )
            else:
                feedback.setProgressText('-- Attribute')
                if key == 'gewaesser':
                    list_primary_key_empty = []
                    prim_key_dict = {}
                    for i, feature in enumerate(layer.getFeatures()):
                        feedback.setProgress(int(i * layer_steps))
                        ft_key = feature.attribute(ereign_gew_id_field)
                        if ft_key in params['emptystrdef']:
                            # fehlender Primaerschluessel
                            list_primary_key_empty.append(feature.id())
                        else:
                            # mehrfache Primaerschluessel ? -> Liste an eindeutigen keys
                            if ft_key in prim_key_dict.keys():
                                prim_key_dict[ft_key].append(feature.id())
                            else:
                                prim_key_dict[ft_key] = [feature.id()]
                    list_primary_key_duplicat = [lst for lst in prim_key_dict.values() if len(lst) > 1]
                    report_dict[key]['attribute'] = {
                        'missing_fields': missing_fields,
                        'primary_key_empty': list_primary_key_empty,
                        'primary_key_duplicat': list_primary_key_duplicat
                    }
                else:  # Attributtest für Ereignisse
                    list_gew_key_empty = []
                    list_gew_key_invalid = []
                    gew_layer = params['layer_dict']['gewaesser']['layer']
                    if ereign_gew_id_field in report_dict['gewaesser']['attribute']['missing_fields']:
                        # 
                        feedback.setProgressText(
                            'Die Zuordnung zum Gewässer kann nicht geprueft werden, weil das Feld \"'
                           + ereign_gew_id_field
                           + '\" im Gewaesserlayer fehlt.'
                        )
                        report_dict[key]['attribute'] = {
                            'missing_fields': missing_fields
                        }
                    else:
                        list_gew_keys = [gew_ft.attribute(ereign_gew_id_field) for gew_ft in gew_layer.getFeatures()]
                        for i, feature in enumerate(layer.getFeatures()):
                            feedback.setProgress(int(i * layer_steps))
                            ft_key = feature.attribute(ereign_gew_id_field)
                            if ft_key in params['emptystrdef']:
                                # fehlender Gewaesserschluessel
                                list_gew_key_empty.append(feature.id())
                            else:
                                if not ft_key in list_gew_keys:
                                    # Der angegebene Gewaesserschluessel(=Gewaessername) ist nicht im Gewaesserlayer vergeben
                                    list_gew_key_invalid.append(feature.id())
                        report_dict[key]['attribute'] = {
                            'missing_fields': missing_fields,
                            'gew_key_empty': list_gew_key_empty,
                            'gew_key_invalid': list_gew_key_invalid
                        }

            # Geometrien
            feedback.setProgressText('-- Geometrien')
            layer_steps = params['layer_dict'][key]['steps']
            """Diese pruefungsroutinen ggf als Funktion, um tests zu schreiben"""
            list_geom_is_empty = []
            list_geom_is_multi = []
            list_geom_sefintersect = []
            feedback.setProgressText('--- Leere und Multigeometrien, Selbstüberschneidungen')
            for i, feature in enumerate(layer.getFeatures()):
                feedback.setProgress(i+1*layer_steps)
                geom = feature.geometry()
                if geom.isEmpty():
                    # Leer?
                    list_geom_is_empty.append(feature.id())
                else:
                    # Multi?
                    if geom.isMultipart():
                        polygeom = geom.asMultiPolyline() 
                    else:
                        polygeom = [f for f in geom.parts()]
                    if len(polygeom) > 1:
                        list_geom_is_multi.append(feature.id())
                # Selbstueberschneidungen
                    if not geom.isSimple():
                        list_geom_sefintersect.append(feature.id())
            report_dict[key]['geometrien'] = {
                    'geom_is_empty': list_geom_is_empty,
                    'geom_is_multi': list_geom_is_multi,
                    'geom_sefintersect': list_geom_sefintersect
                }

            feedback.setProgressText('--- Duplikate und Überschneidungen')
            if not ((key in ['rohrleitungen', 'durchlaesse']) and ('layer_rldl' in params.keys())):
                # Normalfall
                list_geom_crossings, list_geom_duplicate = check_duplicates_crossings(
                    layer,
                    feedback,
                    layer_steps
                )
                report_dict[key]['geometrien']['geom_crossings'] = list_geom_crossings
                report_dict[key]['geometrien']['geom_duplicate'] = list_geom_duplicate
            else:
                if not 'rldl' in report_dict.keys():  # falls es nicht schon einmal durchlaufen wurde
                    layer_rldl = params['layer_rldl']
                    list_geom_crossings, list_geom_duplicate = check_duplicates_crossings(
                        layer_rldl,
                        feedback,
                        layer_steps
                    )
                    dict_alternative_id = {feature.id(): feature[params['field_merged_id']] for feature in layer_rldl.getFeatures()}
                    list_geom_crossings_adjusted = lst_replace(list_geom_crossings, dict_alternative_id)
                    list_geom_duplicate_adjusted = lst_replace(list_geom_duplicate, dict_alternative_id)
                    report_dict['rldl'] = {
                        'geometrien': {
                            'geom_crossings': list_geom_crossings_adjusted,
                            'geom_duplicate': list_geom_duplicate_adjusted
                        }
                    }


            if key == 'gewaesser':
                pass
                # feedback.setProgressText('--- Wasserscheiden, Senken')
            else:  # Ereignisse
                feedback.setProgressText('--- Korrekte Lage von Ereignissen auf Gewässern')
                gew_layer = params['layer_dict']['gewaesser']['layer']
                # gewaesser finden
                report_dict[key]['geometrien']['geom_ereign_auf_gew'] = {}
                for i, feature in enumerate(layer.getFeatures()):
                    feedback.setProgress(i+1*layer_steps)
                    feature_id = feature.id()
                    if feature_id in list_geom_is_empty:
                        pass
                    elif feature_id in list_geom_is_multi: 
                        pass
                    else:
                        #Linie / Punkt auf Gewaesserlinie ?
                        geom = feature.geometry()
                        if type(geom) == 0:  # Point
                            line_feature = get_line_to_check(geom, gew_layer)
                            if not check_vtx_distance(geom, line_feature.geometry()):
                                dict_vtx_bericht = {feature_id: {'Lage': 1}}
                            else:
                                dict_vtx_bericht = {feature_id: {'Lage': 0}}  # hier später noch die Stationierung
                        else:
                            dict_vtx_bericht = {feature_id: check_geom_on_line(geom, gew_layer, with_stat=True)}
                    report_dict[key]['geometrien']['geom_ereign_auf_gew'].update(dict_vtx_bericht)
                if key == 'schaechte':
                    pass
                    """
                    list_geom_schacht_auf_rldl = []
                    # die zusammenführen; das ohnehin nach oben
                    
                    other_layer = merged
                    # rl/dl-Linie finden
                    for i, feature in enumerate(layer.getFeatures()):
                        feedback.setProgress(i+1*layer_steps)
                        feature_id = feature.id()
                        if feature_id in list_geom_is_empty:
                            pass
                        elif feature_id in list_geom_is_multi: 
                            pass
                        else:
                            #Punkt auf Linie
                            geom = feature.geometry()
                            line_feature = get_line_to_check(geom, other_layer)
                            if not check_vtx_distance(geom, line_feature.geometry()):
                                list_geom_schacht_auf_rldl.append({feature_id: 1})
                        report_dict[key]['geometrien']['ereign_auf_rldl'] = list_geom_schacht_auf_rldl
                    """
            feedback.setProgressText('Abgeschlossen \n ')

        # run test
        for key in params['layer_dict'].keys():
            if key in report_dict.keys():
                main_check(key, report_dict, params, feedback)

        import json
        import json
        # dict_ereign_fehler
        with open(reportdatei, 'w', encoding='utf-8') as f:
            json.dump(report_dict, f, ensure_ascii=False, indent=4)
        feedback.setProgressText('Bericht gespeichert unter: \n'+str(reportdatei))
        return {}

    def name(self):
        return 'Pruefroutine_Gewaesserdaten'

    def displayName(self):
        return 'Pruefroutine_Gewaesserdaten'

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Pruefroutinen'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return checkGewaesserDaten()
