# -*- coding: utf-8 -*-

"""
/***************************************************************************
 OSWeGe-Tools - a QGIS plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-09
        copyright            : (C) 2024 by Jannik Schilling
        email                : jannik.schilling@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2024-04-09'
__copyright__ = '(C) 2024 by Jannik Schilling'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    NULL,
    QgsExpression,
    QgsFeatureRequest,
    QgsGeometry,
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsProcessingParameterField,
    QgsProcessingParameterFileDestination,
    QgsProcessingParameterVectorLayer,
    QgsSpatialIndex
)
from qgis import processing

from .defaults import (
    distanz_suchen,
    pflichtfelder,
    list_ereign_gew_id_fields,
    minimallaenge_gew,
    oswScriptType
)
from .pruefungsroutinen import (
    check_geometrie_wasserscheide_senke,
    check_vtx_on_line
)
from .meldungen import fehlermeldungen_generieren

class checkGewaesserDaten(QgsProcessingAlgorithm):
    """
    Prueft Gewaesserdaten
    """
    LAYER_GEWAESSER = 'LAYER_GEWAESSER'
    LAYER_ROHLEITUNGEN = 'LAYER_ROHLEITUNGEN'
    LAYER_DURCHLAESSE = 'LAYER_DURCHLAESSE'
    LAYER_WEHRE = 'LAYER_WEHRE'
    LAYER_SCHAECHTE = 'LAYER_SCHAECHTE'
    REPORT = 'REPORT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_GEWAESSER,
                self.tr('Gewässer-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_ROHLEITUNGEN,
                self.tr('Rohrleitungs-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_DURCHLAESSE,
                self.tr('Durchlässe-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_WEHRE,
                self.tr('Wehre-Layer'),
                [QgsProcessing.SourceType.TypeVectorPoint],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_SCHAECHTE,
                self.tr('Schächte-Layer'),
                [QgsProcessing.SourceType.TypeVectorPoint],
                optional = True
            )
        )


        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.REPORT,
                self.tr('Reportdatei'),
                'Json File (*.json)'                #'Textdatei (*.txt)',
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Hier findet die Verarbeitung statt
        """
        layer_gew = self.parameterAsVectorLayer(parameters, self.LAYER_GEWAESSER, context)
        layer_rohrleitungen = self.parameterAsVectorLayer(parameters, self.LAYER_ROHLEITUNGEN, context)
        layer_durchlaesse = self.parameterAsVectorLayer(parameters, self.LAYER_DURCHLAESSE, context)
        layer_wehre = self.parameterAsVectorLayer(parameters, self.LAYER_WEHRE, context)
        layer_schaechte = self.parameterAsVectorLayer(parameters, self.LAYER_SCHAECHTE, context)
        reportdatei = self.parameterAsString(parameters, self.REPORT, context)

        # Zusammenfassendes dictionary fuer Prozessparameter
        params = {
            'layer_dict': {
                'gewaesser': {'layer': layer_gew},
                'rohrleitungen': {'layer': layer_rohrleitungen},
                'durchlaesse': {'layer': layer_durchlaesse},
                'wehre': {'layer': layer_wehre},
                'schaechte': {'layer': layer_schaechte},
            },
            'feedback': feedback,
            'ereign_gew_id_field': list_ereign_gew_id_fields[1],  # gu_cd, ba_cd
            'emptystrdef': [NULL, ''],  # mögliche "Leer"-Definitionen für Zeichketten
        }

        # dictionary fuer Feedback / Fehlermeldungen
        report_dict = {}
        """
        report_dict = {
            'gewaesser': {
                'name': 'so heisst die Datei",
                'attribute': {
                    'missing_fields': [],
                    'primary_key_empty': [id1, id2],
                    'primary_key_duplicat': [[id3, id4],[id5, id6, id7]]
                },
                'geometrien': {
                    fehler1: [],
                    fehler2: []
                }
            },
            'rohrleitungen': {
                'name': 'so heisst die Datei",
                'attribute': {
                    'missing_fields': [],
                    #'primary_key_empty': [id1, id2],
                    #'primary_key_duplicat': [[id3, id4],[id5, id6, id7]],
                    'gew_key_empty': [id1, id2],
                    'gew_key_invalid': [id4, id5] /  # nicht im layer_gew
                },
                'geometrien': {
                    fehler1: [],
                    fehler2: []
                }
            }
        }
        """

        feedback.setProgressText('Prüfe Attribute:')
        for key, value in params['layer_dict'].items():
            layer = value['layer']
            if layer:
                # Anzahl Objekte fuer das Feedback
                ft_count = layer.featureCount() if layer.featureCount() else 0
                layer_steps = 100.0/ft_count if ft_count != 0 else 0
                params['layer_dict'][key].update({
                    'count': ft_count,
                    'steps': layer_steps
                })
                report_dict[key] = {'name': layer.name()}

        def main_check(key, report_dict, params):
            """
            Diese Hauptfunktion wird durchlaufen, um alle Layer zu pruefen
            :param str key
            :param dict report_dict
            :param dict params
            """
            layer = params['layer_dict'][key]['layer']
            # pflichtfelder vorhanden?
            pflichtfelder_i = pflichtfelder[key]
            layer_i_felder = layer.fields().names()
            missing_fields = [feld for feld in pflichtfelder_i if not feld in layer_i_felder]

            # Attribute
            emptystrdef = params['emptystrdef']
            ereign_gew_id_field = params['ereign_gew_id_field']
            if ereign_gew_id_field in missing_fields:
                report_dict[key]['attribute'] = {
                    'missing_fields': missing_fields
                }
                """hier noch den layer einbauen"""
                feedback.setProgressText('Primärschlüssel fehlt; Attributtest wird übersprungen')
            else:
                if key == 'gewaesser':
                    list_primary_key_empty = []
                    prim_key_dict = {}
                    for feature in layer.getFeatures():
                        ft_key = feature.attribute(ereign_gew_id_field)
                        if ft_key in emptystrdef:
                            # fehlender Primaerschluessel
                            list_primary_key_empty.append(feature.id())
                        else:
                            # mehrfache Primaerschluessel ? -> Liste an eindeutigen keys
                            if ft_key in prim_key_dict.keys():
                                prim_key_dict[ft_key].append(feature.id())
                            else:
                                prim_key_dict[ft_key] = [feature.id()]
                    list_primary_key_duplicat = [lst for lst in prim_key_dict.values() if len(lst) > 1]
                    report_dict[key]['attribute'] = {
                        'missing_fields': missing_fields,
                        'primary_key_empty': list_primary_key_empty,
                        'primary_key_duplicat': list_primary_key_duplicat
                    }
                else:  # Attributtest für Ereignisse
                    list_gew_key_empty = []
                    list_gew_key_invalid = []
                    gew_layer = params['layer_dict']['gewaesser']['layer']
                    if ereign_gew_id_field in report_dict['gewaesser']['attribute']['missing_fields']:
                        # Uebereinstimmtung kann nicht geprueft werden, weil der Primaerschluessel beim Gewaesser fehlt
                        report_dict[key]['attribute'] = {
                            'missing_fields': missing_fields
                        }
                    else:
                        list_gew_keys = [gew_ft.attribute(ereign_gew_id_field) for gew_ft in gew_layer.getFeatures()]
                        for feature in layer.getFeatures():
                            ft_key = feature.attribute(ereign_gew_id_field)
                            if ft_key in emptystrdef:
                                # fehlender Gewaesserschluessel
                                list_gew_key_empty.append(feature.id())
                            else:
                                if not ft_key in list_gew_keys:
                                    # Der angegebene Gewaesserschluessel(=Gewaessername) ist nicht im Gewaesserlayer vergeben
                                    list_gew_key_invalid.append(feature.id())
                        report_dict[key]['attribute'] = {
                            'missing_fields': missing_fields,
                            'gew_key_empty': list_gew_key_empty,
                            'gew_key_invalid': list_gew_key_invalid
                        }


            # Geometrien
            layer_steps = params['layer_dict'][key]['steps']
            list_geom_is_empty = []
            list_geom_is_multi = []
            list_geom_sefintersect = []
            for i, feature in enumerate(layer.getFeatures()):
                """Diese pruefungsroutinen ggf als Funktion, um tests zu schreiben"""
                geom = feature.geometry()
                # Leer?
                geom_is_empty = geom.isEmpty()
                # Multi?
                if geom_is_empty:
                    list_geom_is_empty.append(feature.id())
                else:
                    if geom.isMultipart():
                        polygeom = geom.asMultiPolyline() 
                    else:
                        polygeom = [f for f in geom.parts()]
                    if len(polygeom) > 1:
                        list_geom_is_multi.append(feature.id())
                # Selbstueberschneidungen
                if not geom.isSimple() and not geom_is_empty:
                    list_geom_sefintersect.append(feature.id())
                feedback.setProgress(i+1*layer_steps)
                report_dict[key]['geometrien'] = {
                    'geom_is_empty': list_geom_is_empty,
                    'geom_is_multi': list_geom_is_multi,
                    'geom_sefintersect': list_geom_sefintersect
                }

            feedback.setProgressText('Duplikate und Überschneidungen prüfen')
            list_geom_duplicate = []
            list_geom_crossings = []
            visited_groups_crossings = set()
            visited_groups_equal = set()
            spatial_index = QgsSpatialIndex(layer.getFeatures())
            for feature in layer.getFeatures():
                feature_id = feature.id()
                if feature_id in list_geom_is_empty:
                    continue
                if feature_id in list_geom_is_multi:  # das vielleicht rauswerfen
                    continue
                geom = feature.geometry()
                intersecting_ids = spatial_index.intersects(geom.boundingBox())
                for fid in intersecting_ids:
                    if fid == feature_id:
                        continue
                    group_i = tuple(sorted([feature_id, fid]))
                    other_feature = layer.getFeature(fid)
                    other_geom = other_feature.geometry()
                    if geom.equals(other_geom):
                        if group_i in visited_groups_equal:
                            pass
                        else:
                            list_geom_duplicate.append(group_i)
                            visited_groups_equal.add(group_i)
                    if geom.crosses(other_geom):
                        if group_i in visited_groups_crossings:
                            pass
                        else:
                            list_geom_crossings.append(group_i)
                            visited_groups_crossings.add(group_i)
            report_dict[key]['geometrien']['geom_crossings'] = list_geom_crossings
            report_dict[key]['geometrien']['geom_duplicate'] = list_geom_duplicate

            if key == 'gewaesser':
                pass
                # wasserscheiden, senken
            else:  # Ereignisse
                list_geom_ereign_auf_gew = []
                gew_layer = params['layer_dict']['gewaesser']['layer']
                spatial_index_gew = QgsSpatialIndex(gew_layer.getFeatures())
                if key in ['rohrleitungen', 'durchlaesse']:  # Linienereignisse (rl und dl)
                    # gewaesser finden
                    for feature in layer.getFeatures():
                        feature_id = feature.id()
                        if feature_id in list_geom_is_empty:
                            pass
                        elif feature_id in list_geom_is_multi: 
                            pass
                        else:
                            #Linie auf Gewaesserlinie
                            geom = feature.geometry()
                            list_vtx_geom = [QgsGeometry(vtx) for vtx in geom.vertices()]
                            intersecting_ids = spatial_index_gew.intersects(geom.boundingBox())
                            if len(intersecting_ids)==1:
                                gew_ft = gew_layer.getFeature(intersecting_ids[0])
                                check_vtx_on_line_num, check_vtx_on_line_txt = check_vtx_on_line(list_vtx_geom, gew_ft, gew_layer)
                                """passt der Gewassername?"""
                            elif len(intersecting_ids)==0:
                                print('0; ft_id='+str(feature.id()))
                                check_vtx_on_line_num = 4
                                check_vtx_on_line_txt = 'Kein Gewässer in der Nähe'
                            else:
                                # mehrere Gewaesser gefunden
                                list_sum = []
                                for gew_id in intersecting_ids:
                                    # identifiziere das Gewaesser mit dem geringsten Abstand der Stützpunkte in Summe
                                    gew_ft_candidate = gew_layer.getFeature(gew_id)
                                    list_sum.append([gew_ft_candidate.geometry().distance(vtx) for vtx in list_vtx_geom])
                                    position_in_list = list_sum.index(min(list_sum))
                                gew_ft = gew_layer.getFeature(intersecting_ids[position_in_list])
                                check_vtx_on_line_num, check_vtx_on_line_txt = check_vtx_on_line(list_vtx_geom, gew_ft, gew_layer)
                                """passt der Gewassername?"""
                            if not check_vtx_on_line_num == 0:
                                list_geom_ereign_auf_gew.append({feature_id: check_vtx_on_line_txt})
                    report_dict[key]['geometrien']['geom_ereign_auf_gew'] = list_geom_ereign_auf_gew
                if key in ['schaechte', 'wehre']:
                    pass
                    """
                    - liegt der schacht auf einem anfangs oder endpunkt von rl /dl (oder überhaupt darauf)
                    - passt das Gewaesser?                    
                    """
        # run test
        for key in params['layer_dict'].keys():
            if key in report_dict.keys():
                feedback.setProgressText('layer: '+key)
                main_check(key, report_dict, params)
        
        import json
        import json
        with open(reportdatei, 'w', encoding='utf-8') as f:
            json.dump(report_dict, f, ensure_ascii=False, indent=4)

        return {}

    def name(self):
        return 'Pruefroutine_Gewaesserdaten'

    def displayName(self):
        return 'Pruefroutine_Gewaesserdaten'

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Pruefroutinen'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return checkGewaesserDaten()
