# -*- coding: utf-8 -*-

"""
/***************************************************************************
 OSWeGe-Tools - a QGIS plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-09
        copyright            : (C) 2024 by Jannik Schilling
        email                : jannik.schilling@uni-rostock.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Jannik Schilling'
__date__ = '2024-04-09'
__copyright__ = '(C) 2024 by Jannik Schilling'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    NULL,
    QgsExpression,
    QgsFeatureRequest,
    QgsGeometry,
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsProcessingParameterField,
    QgsProcessingParameterFileDestination,
    QgsProcessingParameterVectorLayer,
    QgsSpatialIndex
)
from qgis import processing
from collections import Counter
import pandas as pd

from .defaults import (
    distanz_suchen,
    pflichtfelder,
    ereign_gew_id_feld,
    minimallaenge_gew,
    oswScriptType
)
from .pruefungsroutinen import (
    check_geometrie_wasserscheide_senke,
    check_geometrie_leer,
    check_geometrie_multi,
    check_geometrie_selbstueberschneidung,
    check_geometrie_ueberschneidung_mit_anderen,
    check_geometrie_duplikat
)
from .meldungen import fehlermeldungen_generieren

class checkGewaesserDaten(QgsProcessingAlgorithm):
    """
    Prueft Gewaesserdaten
    """
    LAYER_GEWAESSER = 'LAYER_GEWAESSER'
    LAYER_ROHLEITUNGEN = 'LAYER_ROHLEITUNGEN'
    LAYER_DURCHLAESSE = 'LAYER_DURCHLAESSE'
    LAYER_WEHRE = 'LAYER_WEHRE'
    LAYER_SCHAECHTE = 'LAYER_SCHAECHTE'
    REPORT = 'REPORT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_GEWAESSER,
                self.tr('Gewässer-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_ROHLEITUNGEN,
                self.tr('Rohrleitungs-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_DURCHLAESSE,
                self.tr('Durchlässe-Layer'),
                [QgsProcessing.SourceType.TypeVectorLine],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_WEHRE,
                self.tr('Wehre-Layer'),
                [QgsProcessing.SourceType.TypeVectorPoint],
                optional = True
            )
        )

        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.LAYER_SCHAECHTE,
                self.tr('Schächte-Layer'),
                [QgsProcessing.SourceType.TypeVectorPoint],
                optional = True
            )
        )


        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.REPORT,
                self.tr('Reportdatei'),
                'Textdatei (*.txt)',
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Hier findet die Verarbeitung statt
        """
        layer_gew = self.parameterAsVectorLayer(parameters, self.LAYER_GEWAESSER, context)
        layer_rohrleitungen = self.parameterAsVectorLayer(parameters, self.LAYER_ROHLEITUNGEN, context)
        layer_durchlaesse = self.parameterAsVectorLayer(parameters, self.LAYER_DURCHLAESSE, context)
        layer_wehre = self.parameterAsVectorLayer(parameters, self.LAYER_WEHRE, context)
        layer_schaechte = self.parameterAsVectorLayer(parameters, self.LAYER_SCHAECHTE, context)
        reportdatei = self.parameterAsString(parameters, self.REPORT, context)

        # Zusammenfassendes dictionary fuer Prozessparameter
        params = {
            'layer_dict': {
                'gewaesser': {'layer': layer_gew},
                'rohrleitungen': {'layer': layer_rohrleitungen},
                'durchlaesse': {'layer': layer_durchlaesse},
                'wehre': {'layer': layer_wehre},
                'schaechte': {'layer': layer_schaechte},
            },
            'feedback': feedback
        }

        # dictionary fuer Feedback / Fehlermeldungen
        report_dict = {}
        """
        report_dict = {
            'gewaesser': {
                'name': 'so heisst die Datei",
                'attribute': {
                    'fehlende_felder': [],
                    'primaerschluessel_leer': [id1, id2],
                    'primaerschluessel_mehrfach': [[id3, id4],[id5, id6, id7]]
                    },
                'geometrien': {
                    fehler1: [],
                    fehler2: []
                }
            },
            'rohrleitungen': {
                'name': 'so heisst die Datei",
                'attribute': {
                    'fehlende_felder': [],
                    #'primaerschluessel_leer': [id1, id2],
                    #'primaerschluessel_mehrfach': [[id3, id4],[id5, id6, id7]],
                    'gewschluessel_leer: [id1, id2],
                    'gewschluessel_ungueltig: [id4, id5] /  # nicht im layer_gew
                    },
                'geometrien': {
                    fehler1: [],
                    fehler2: []
                }
            }
        }
        """

        feedback.setProgressText('Prüfe Attribute:')
        for key, value in params['layer_dict'].items():
            layer = value['layer']
            if layer:
                # Anzahl Objekte
                ft_count = layer.featureCount() if layer.featureCount() else 0
                layer_steps = 100.0/ft_count if ft_count != 0 else 0
                params['layer_dict'][key].update({
                    'count': ft_count,
                    'steps': layer_steps
                })

                # pflichtfelder vorhanden?
                pflichtfelder_i = pflichtfelder[key]
                layer_i_felder = layer.fields().names()
                fehlende_felder = [feld for feld in pflichtfelder_i if not feld in layer_i_felder]
                
                if key == 'gewaesser':
                    #primaerschluessel_leer
                    #primaerschluessel_mehrfach
                else:
                    
        """
        # Pruefroutinen fuer Attribute
        if report_dict['Test_COL_ID_vorhanden']['Report'] == 0:
            datagen = (
                [
                    ft.id(),
                    ft[feld_gew_name],
                ] for ft in layer_gew.getFeatures()
            )
            df_gew = pd.DataFrame.from_records(
                data=datagen,
                columns=[
                    'id',
                    feld_gew_name
                ]
            )
            del datagen


            # eindeutiger Gewaessername?
            feedback.setProgressText('- eindeutiger Gewaessername')
            name_Counter = Counter(df_gew[feld_gew_name])
            val_list = []
            steps = len(name_Counter)/100
            i = 0
            for val, ct in name_Counter.items():
                if val != NULL:
                    if ct == 1:
                        pass
                    else:
                        val_list = val_list + [df_gew.loc[df_gew[feld_gew_name]==val, 'id'].tolist()]
                i = i+1
                feedback.setProgress(int(i * steps))
            report_dict['Test_VAL_ID_DUPLICAT'] = {
                    'Typ': 'Attribut',
                    'Spalte': feld_gew_name,
                    'Report': oswDataFeedback.VAL_DUPLICAT,
                    'Objekte': val_list
                }
                


            # fehlender Gewaessername?
            feedback.setProgressText('- fehlende Gewaessernamen')
            val_list = []
            for i, val in enumerate(df_gew[feld_gew_name]):
                if check_wert_fehlend(val) == 0:
                    pass
                else:
                    val_list = val_list + [df_gew.loc[i, 'id']]
                feedback.setProgress(int(i * total_gew_steps))
            report_dict['Test_VAL_ID_MISSING'] = {
                'Typ': 'Attribut',
                'Spalte': feld_gew_name,
                'Report': oswDataFeedback.VAL_MISSING,
                'Objekte': val_list
            }
            del df_gew


        # Pruefroutinen fuer Geometrien
        feedback.setProgressText('Prüfe auf Geometriefehler:')
        datagen = (
            [
                ft.id(),
                ft.geometry()
            ] for ft in layer_gew.getFeatures()
        )
        df_gew = pd.DataFrame.from_records(
            data=datagen,
            columns=[
                'id',
                'geometrie'
            ]
        )
        del datagen

        # leere Geometrien
        feedback.setProgressText('- leere Geometrien')
        val_list = []
        for i, val in enumerate(df_gew['geometrie']):
            if check_geometrie_leer(val) == 0:
                pass
            else:
                val_list = val_list + [df_gew.loc[i, 'id']]
            feedback.setProgress(int(i * total_gew_steps))
        report_dict['Test_GEOM_EMPTY'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_EMPTY,
            'Objekte': val_list
        }

        # Multigeometrien
        feedback.setProgressText('- Multigeometrien')
        val_list = []
        for i, val in enumerate(df_gew['geometrie']):
            if check_geometrie_multi(val) == 0:
                pass
            else:
                val_list = val_list + [df_gew.loc[i, 'id']]
            feedback.setProgress(int(i * total_gew_steps))
        report_dict['Test_GEOM_MULTI'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_MULTI,
            'Objekte': val_list
        }


        # Selbstueberschneidungen
        feedback.setProgressText('- Selbstüberschneidungen')
        val_list = []
        for i, val in enumerate(df_gew['geometrie']):
            if check_geometrie_selbstueberschneidung(val) == 0:
                pass
            else:
                val_list = val_list + [df_gew.loc[i, 'id']]
            feedback.setProgress(int(i * total_gew_steps))
        report_dict['Test_GEOM_SELFINTERSECT'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_SELFINTERSECT,
            'Objekte': val_list
        }

        # Ueberschneidung mit anderen Geometrien
        feedback.setProgressText('- Ueberschneidung mit anderen Geometrien')
        val_list = []
        for i, geom in enumerate(df_gew['geometrie']):
            check = check_geometrie_ueberschneidung_mit_anderen(
                geom,
                df_gew.loc[i, 'id'],
                df_gew
            ) 
            if check == 0:
                pass
            else:
                if not any([all(fid in lst for fid in check[1]) for lst in val_list]):
                    val_list = val_list + [check[1]]
            feedback.setProgress(int(i * total_gew_steps))
        report_dict['Test_GEOM_INTERSECT'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_INTERSECT,
            'Objekte': val_list
        }

        # Doppelte Geometrien
        feedback.setProgressText('- Doppelte Geometrien')
        val_list = []
        for i, geom in enumerate(df_gew['geometrie']):
            check = check_geometrie_duplikat(
                geom,
                i,
                df_gew['geometrie'],
                with_id=True,
                df_gew=df_gew
            ) 
            if check == 0:
                pass
            else:
                if not any([all(fid in lst for fid in check[1]) for lst in val_list]):
                    val_list = val_list + [check[1]]
            feedback.setProgress(int(i * total_gew_steps))
        report_dict['Test_GEOM_DUPLICAT'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_DUPLICAT,
            'Objekte': val_list
        }

        # Konnektivitaet
        feedback.setProgressText('- Konnektivität')
        feedback.setProgressText('> Wasserscheiden')
        val_list = []
        for i, geom in enumerate(df_gew['geometrie']):
            check = check_geometrie_wasserscheide_senke(
                geom,
                df_gew.loc[i,'id'],
                senke=False,
                **params
            )
            if check == 0:
                pass
            else:
                dupl = False
                check[1].sort()
                if "Test_GEOM_DUPLICAT" in report_dict.keys():
                    if check[1] in report_dict["Test_GEOM_DUPLICAT"]['Objekte']:
                        dupl = True
                if not dupl:
                    if not any([all(fid in lst for fid in check[1]) for lst in val_list]):
                        val_list = val_list + [check[1]] 
            feedback.setProgress(int(i * total_gew_steps))
        report_dict['Test_GEOM_WASSERSCHEIDE'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_WASSERSCHEIDE,
            'Objekte': val_list
        }

        feedback.setProgressText('> Senken')
        val_list = []
        for i, geom in enumerate(df_gew['geometrie']):
            check = check_geometrie_wasserscheide_senke(
                geom,
                df_gew.loc[i,'id'],
                senke=True,
                **params
            ) 
            if check == 0:
                pass
            else:
                dupl = False
                check[1].sort()
                if "Test_GEOM_DUPLICAT" in report_dict.keys():
                    if check[1] in report_dict["Test_GEOM_DUPLICAT"]['Objekte']:
                        dupl = True
                if not dupl:
                    if not any([all(fid in lst for fid in check[1]) for lst in val_list]):
                        val_list = val_list + [check[1]] 
            feedback.setProgress(int(i * total_gew_steps))
        report_dict['Test_GEOM_SENKE'] = {
            'Typ': 'Geometrie',
            'Report': oswDataFeedback.GEOM_SENKE,
            'Objekte': val_list
        }

        # Geometrieprüfungen hier nur fuer Ereignisse
        layer_typ = ''
        if layer_typ == 'Ereignis':
            # Übereinstimmung mit Gewässergeometrie
            feedback.setProgressText('- Übereinstimmung mit Gewässergeometrie')
            
            feedback.setProgressText('> Gewässername prüfen')
            ereign_joined_layer = processing.run(
                "native:joinbynearest",
                {
                    'INPUT': layer_ereign,
                    'INPUT_2': layer_gew,
                    'FIELDS_TO_COPY': ['ba_cd'],
                    'DISCARD_NONMATCHING': False,
                    'PREFIX':'gew_', 
                    'NEIGHBORS':1, 
                    'MAX_DISTANCE': None,
                    'OUTPUT':'memory:'
                },
                context=context,
                feedback=feedback
            )['OUTPUT']
            for i, ft in enumerate(ereign_joined_layer.getFeatures()):
                if ft['ba_cd'] == ft['gew_ba_cd']:
                    pass
                else:
                    print('Falscher Gewässername' + str(i))

            if layer_ereign.geometryType() == 1:
                feedback.setProgressText('> Geometrieübereinstimmung prüfen')
                val_list = []
                for i, ft in enumerate(ereign_joined_layer.getFeatures()):
                    geom_i = ft.geometry()
                    # check if null or multi
                    req_expression = QgsExpression("\"ba_cd\" = \'"+str(ft['gew_ba_cd'])+"\'")
                    gew_i = [f for f in layer_gew.getFeatures(QgsFeatureRequest(req_expression))][0]
                    gew_i_geom = gew_i.geometry()
                    vtx_df = pd.DataFrame({
                        'ereign_sp': [QgsGeometry.fromPoint(vtx) for vtx in geom_i.vertices()],
                        'naechster_gew_sp_idx': np.nan,
                        'distanz_sp': np.nan,
                        'distanz_gew': np.nan,
                    })
                    
                    vtx_df_maxIndex = vtx_df.index[-1]
                    ereign_vtx_start_geom = vtx_df['ereign_sp'][0]
                    ereign_vtx_ende_geom = vtx_df['ereign_sp'][vtx_df_maxIndex]
                    ereign_vtc_mittel_geom = vtx_df['ereign_sp'][1:vtx_df_maxIndex]

                    # naechster Punkt auf dem Gewässer
                    nearest_gew_point_start = gew_i_geom.nearestPoint(ereign_vtx_start_geom)
                    nearest_gew_xy_start = nearest_gew_point_start.asPoint()
                    nearest_gew_point_ende = gew_i_geom.nearestPoint(ereign_vtx_ende_geom)
                    nearest_gew_xy_ende = nearest_gew_point_ende.asPoint()

                    # naechster Stuetzpunkt danach
                    stp_start = gew_i_geom.closestSegmentWithContext(nearest_gew_xy_start)[2]
                    stp_stop = gew_i_geom.closestSegmentWithContext(nearest_gew_xy_ende)[2]
                    gew_idx_mittlere_vtc = list(range(stp_start, stp_stop))  # indices der mittleren Stuetzpunkte
                    
                    # Distanz zu den Stuetzpunkten
                    for ereign_vtx_idx in vtx_df.index:
                        ereign_vtx_geom = vtx_df['ereign_sp'][ereign_vtx_idx]
                        ereign_vtx_XY = ereign_vtx_geom.asPoint()  # XY-Geometrie des Ereignisstützpunkts
                        if ereign_vtx_idx == 0:
                            pass
                        elif ereign_vtx_idx == vtx_df_maxIndex:
                            pass
                        else:
                            gew_vtx_dist, gew_vtx_idx = gew_i_geom.closestVertexWithContext(ereign_vtx_XY)
                            vtx_df.loc[ereign_vtx_idx, 'distanz_sp'] = gew_vtx_dist
                            vtx_df.loc[ereign_vtx_idx, 'naechster_gew_sp_idx'] = gew_vtx_idx
                        vtx_df.loc[ereign_vtx_idx, 'distanz_gew'] = gew_i_geom.closestSegmentWithContext(ereign_vtx_XY)[0]
                    if all(x == 0 for x in vtx_df['distanz_gew']):
                        pass
                    else:
                        val_list = val_list + [ft.id()]
                    del vtx_df
                    feedback.setProgress(int(i * total_steps))
                report_dict['Test_GEOM_NOT_ON_GEWLINE'] = {
                    'Typ': 'Geometrie',
                    'Report': oswDataFeedback.GEOM_NOT_ON_GEWLINE,
                    'Objekte': val_list
                }
            else: # Punkte
                feedback.setProgressText('> Lage der Punktgeometrie prüfen')
                val_list = []


        # Bericht zusammenstellen
        with open(reportdatei, 'w') as f:
            f.write(
                '**************************************'
                + '\nÜberprüfung des (Basis-)Gewässerlayers'
                + '\n\nLayer: ' + str(layer_gew)
                + '\n**************************************\n\n'
            )
            for val in report_dict.values():
                f.write(fehlermeldungen_generieren(val))

        feedback.pushInfo('Report gespeichert in ' + str(reportdatei)+ '\n')
        """
        return {}

    def name(self):
        return 'Pruefroutine_Gewaesserdaten'

    def displayName(self):
        return 'Pruefroutine_Gewaesserdaten'

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Pruefroutinen'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return checkGewaesserDaten()
